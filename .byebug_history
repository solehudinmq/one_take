exit
expect(e.message).to eq("header 'x-idempotency-key' is required to be sent.")
e.message
exit
data = result['data']
result
c
result
c
expect(data["content"]).to eq('Content post 1')
expect(data["title"]).to eq('Post 1')
data
c
result
c
result
exit
result
exit
result
exit
redis_conn.expire(response_key, REDIS_EXPIRE)
redis_conn.hset(response_key, 'data', result.to_json)
redis_conn.hset(response_key, 'data', result)
redis_conn.hset(response_key, 'status', 'success')
result
response_key
c
exit
result = yield
lock_key
@redis_pool.with do |redis_conn|
          redis_conn.set(lock_key, lock_value, nx: true, ex: LOCK_TIMEOUT)
        end
lock_value = generate_lock_value
lock_key = "#{LOCK_KEY_PREFIX}#{idempotency_key}"
exit
e.message
e.messages
e.message
exit
ENV['LOCK_TIMEOUT'].to_i
ENV['LOCK_TIMEOUT']
LOCK_TIMEOUT
REDIS_URL
exit
@redis_pool.with
@redis_pool
exit
response_key
cached_response = @redis_pool.with do |redis_conn| redis_conn.hgetall(response_key) end
cached_response = @redis_pool.with do |redis_conn|
cached_response = response_data_in_cache(response_key)
response_key = "#{IDEMPOTENCY_KEY_PREFIX}#{idempotency_key}"
